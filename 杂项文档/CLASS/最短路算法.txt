Bellmans-ford   o(VE)
重点:无负圈。 DAG
d[s]=0;
for (int k=1;k<=V-1;++k){
	bool update=false;
	for (int i=0;i<G.size();++i){
		Edge &e=G[i];
		if (d[e.v]>d[e.u]+e.cost){
			更新，update=true;
}
}
}
1.13|E|
0.95|E|

for (int k=1;k<=V-1;++k){
	bool update=false;
	for (int i=0;i<G.size();++i){
		Edge &e=G[i];
		if (d[e.v]>d[e.u]+e.cost){
			更新
		if (k==V) return true;负圈
}
}
}

SPFA  O(KE)
最坏情况和BEllman一样

DIjkstra
无负权边！
找出最小，更新其他。
最小堆优化：
struct Edge{
int to cost;
};
vector<edge> G[maxV];
struct Sta{
int u,did;
bool operator<(const Sta &rhs) const{
	return dis > rhs.dis;
}
};
O(ElogV)









